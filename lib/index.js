var D=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var l=Object.prototype.hasOwnProperty;var T=t=>D(t,"__esModule",{value:!0});var y=(t,e)=>{for(var n in e)D(t,n,{get:e[n],enumerable:!0})},b=(t,e,n,a)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of p(e))!l.call(t,r)&&(n||r!=="default")&&D(t,r,{get:()=>e[r],enumerable:!(a=d(e,r))||a.enumerable});return t};var x=(t=>(e,n)=>t&&t.get(e)||(n=b(T({}),e,1),t&&t.set(e,n),n))(typeof WeakMap!="undefined"?new WeakMap:0);var w={};y(w,{chunkDate:()=>C});function u(t){return t instanceof Date}function f(t){return Object.prototype.toString.call(t)==="[object Number]"}var h={ms:1,s:1e3,m:6e4,h:36e5,d:864e5};function s(t){return t instanceof Date?t.valueOf():t}function C(t){if(typeof t=="undefined")return console.error("date-chunk: options are required in chunkDate function"),[];let{start:e,end:n}=t,a=u(e)||f(e);return!(u(n)||f(n))||!a?(console.error("date-chunk: start or end must be either Date object or number (timestamp) in chunkDate function"),[]):"chunks"in t?L(t):"maxLimitPerChunk"in t?O(t):[]}function L(t){let e=[],a=(s(t.end)-s(t.start))/t.chunks;t.strictSizedChunks&&(a=Number(a.toFixed()));let r=s(t.start);for(let m=0;m<t.chunks;m++){let i=r+a;e.push({start:u(t.start)?new Date(r):r,end:u(t.end)?new Date(i):i}),r=i}return e}function O(t){let e=t.maxLimitPerChunk[0],n=h[t.maxLimitPerChunk[1]],a=[],r=s(t.end)-s(t.start),m=e*n,i=r/m,c=s(t.start);for(;i>0;){let k=i>=1?1:i,o=c+m*k;a.push({start:u(t.start)?new Date(c):c,end:u(t.end)?new Date(o):o}),c=o,i--}return a}module.exports=x(w);
